% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/extract.R
\name{extract}
\alias{extract}
\title{extract}
\usage{
extract(df, ..., ignore.case = FALSE, perl = FALSE, fixed = FALSE,
  useBytes = FALSE, row.names = NULL, check.rows = FALSE,
  check.names = TRUE, fix.empty.names = TRUE,
  stringsAsFactors = default.stringsAsFactors())
}
\arguments{
\item{df}{data frame to use}

\item{...}{variables to extract}

\item{ignore.case}{if \code{FALSE}, the pattern matching is \emph{case
      sensitive} and if \code{TRUE}, case is ignored during matching.}

\item{perl}{logical.  Should Perl-compatible regexps be used?}

\item{fixed}{logical.  If \code{TRUE}, \code{pattern} is a string to be
    matched as is.  Overrides all conflicting arguments.}

\item{useBytes}{logical.  If \code{TRUE} the matching is done
    byte-by-byte rather than character-by-character.  See
    \sQuote{Details}.}

\item{row.names}{\code{NULL} or a single integer or character string
    specifying a column to be used as row names, or a character or
    integer vector giving the row names for the data frame.}

\item{check.rows}{if \code{TRUE} then the rows are checked for
    consistency of length and names.}

\item{check.names}{logical.  If \code{TRUE} then the names of the
    variables in the data frame are checked to ensure that they are
    syntactically valid variable names and are not duplicated.
    If necessary they are adjusted (by \code{\link{make.names}})
    so that they are.}

\item{fix.empty.names}{logical indicating if arguments which are
    \dQuote{unnamed} (in the sense of not being formally called as
    \code{someName = arg}) get an automatically constructed name or
    rather name \code{""}.  Needs to be set to \code{FALSE} even when
    \code{check.names} is false if \code{""} names should be kept.}

\item{stringsAsFactors}{logical: should character vectors be converted
    to factors?  The \sQuote{factory-fresh} default is \code{TRUE}, but
    this can be changed by setting \code{\link{options}(stringsAsFactors
      = FALSE)}.}
}
\value{
a new data frame
}
\description{
Extracts variables from data frame following patterns given in \code{...}. The variable names
}
\examples{
data(ansur2)
## extract variable(s) and store them with the same name
x <- extract(ansur2, 'Age', 'Gender')
head(x)
## extract variable(s) and rename them
x <- extract(ansur2, age='Age', gender='Gender')
## extract all 'buttock' variables and store them with the same name
x <- extract(ansur2, 'buttock')
head(x)
## extract all 'buttock' variables and store them with different name
x <- extract(ansur2, Buttock='buttock')
## extract all variables which contain 'height' in the name 
x <- extract(ansur2, 'height')
head(x)
## extract all variables which end on 'height'
x <- extract(ansur2, 'height$')
head(x)
## a full example
x <- extract(ansur2, Weight='weight', 'Age', 'Gender', Height='Height', 
                     Writing='Writing', Race='DODRace')
names(x)
head(x)
## Weight in kg, Height in meter, Race as factor variable
x$Weight <- x$Weight/10
x$Height <- x$Height*2.54/100
lvl      <- c('White', 'Black', 'Hispanic', 'Asian', 'Native', 'Islander', 'Other')
x$Race   <- factor(lvl[x$Race])
}
